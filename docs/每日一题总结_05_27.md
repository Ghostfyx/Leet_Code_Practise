# 974 可被K整除的子数组

看到子数组和，立马联系到前缀和。

## 1. 前缀和

前面的所有，再包括自己（数组 第 0 项 到 当前项 的 总和）。如果用一个数组 preSum 表示：

- preSum[0]：数组A 第 0 项 到 第 0 项 的总和
- preSum[1]：数组A 第 0 项 到 第 1 项 的总和
- preSum[2]：数组A 第 0 项 到 第 2 项 的总和
- preSum[3]：数组A 第 0 项 到 第 3 项 的总和
- …… 

于是有：
$$
preSum[i] = A[0] + A[1] +…+A[i]
$$
数组某项，可以表示为相邻前缀和之差：
$$
A[i] = preSum[i] - preSum[i - 1]
$$
叠加多项，等号右边加减相消：
$$
A[i] +…+A[j]=preSum[j] - preSum[i - 1]
$$
$i $当然可以为 0，此时 $i-1$ 为 - 1，我们故意让 $preSum[-1]$ 为 0，此时：
$$
A[0] +A[1]+…+A[j]=preSum[j]
$$
这么做是为了让边界情况也能套用通式（通式也能成立）

## 2. 题目描述转换为前缀和描述

原有题目描述关键点：

- 子数组的元素之和，就是数组 **第 i 项 到 第 j 项 的和**
- 元素之和能被 K 整除的子数组数目 就是 有几种 i、j 组合，使得 第 i ~ j 项的和 mod K == 0

↓ ↓ ↓ **转化为** ↓ ↓ ↓

- 有几种$ i、j$组合，满足
	$$
	(preSum[ j ] - preSum[ i - 1 ])mod K== 0
	$$

- 有几种$ i、j$组合，满足
	$$
	preSum[j] mod K == preSum[i-1] mod K
	$$
	​	

**注意前提**： $preSum[j]$与 $preSum[i-1]$ 为正整数

到此题目转换为：**求解preSum[i]集合中两两mok K相等的元素**

## 3. 引入Hash表

- 因为我们不关心 前缀和 对应数组 A 的哪一项，即 不关心具体位置只关心出现过哪些 前缀和 % K 的结果，和对应的 出现次数
- 改用一个变量 preSum ，保存每次求出的前缀和 mod K，存入哈希表
- map 不含多余信息，存键值对：
	- key：前缀和 mod K 。数值作为 key
	- value：这个结果值出现了几次

注意到， 前缀和 mod K 的值正好是 0,1,2...,K-10,1,2...,*K*−1，恰似索引，也可以用**数组**存。

## 4. 核心流程

1. 预置边界情况 (即$ preSum[-1] = 0$)：遍历数组 A 之前，map 提前放入 0:1，求第 0 项前缀和之前，前缀和 mod K 等于 0 已经出现 1 次
2. 遍历数组 A 的每一项，求当前项的前缀和 mod K ，存入 map 中
	- 之前没有存过，则作为 key 存入，值为 1
	- 之前存过，则对应值 +1
3. **边存边查看 map** ，如果 **map** 中已存在 **key** 为 **当前前缀和 mod K**
	- 说明存在 **之前求过的某个前缀和**，**它 mod K** **==** **当前前缀和 mod K**
	- 把满足条件的 key 对应的出现次数，累加给 count

